# [iOS 꼼재] 화면상의 객체를 제어하는 방법 : @IBOutlet 그리고 @IBAction ✍🏻

꼼재 개발일지를 처음 작성해본다! 이걸 개발일지라고 할 수 있을지는 잘 모르겠지만...👀  

이번 챕터에서는 **"화면상의 객체를 제어하는 방법 : @IBOutlet 그리고 @IBAction"**에 대해 우선 배워 보았다.    


📌 **<u>어노테이션(Annotation)</u>** : 컴파일러에게 주로 변수나 메소드의 성격을 알려주는 역할

- **"<u>@IB</u>"** 가 붙는 프로퍼티나 메소드는 인터페이스 빌더에 관련된 것이라는 의미를 나타낸다. (접두어 **IB**가 **인터페이스 빌더 (Interface Builder)**를 의미) : **<u>인터페이스 빌더 어노테이션</u>**


## 🖋 @IBOutlet - 객체의 참조

화면상의 객체를 소스 코드에서 참조하기 위해 사용하는 어노테이션.
인터페이스 빌더의 객체와 클래스의 프로퍼티는 당연히 서로 타입이 일치해야 한다.

**<u>@IBOutlet</u>으로 정의된 프로퍼티**를 우리는 **<u>아울렛 변수</u>**라고 부른다.   

### 📌  Strong / Weak

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>     

진동 기능은 시뮬레이터에서 동작하지 않는다!        
진동 기능을 넣는다고 코드 자체가 잘못되는 것은 아니지만 <strong>확인은 불가</strong>함 🙅🏻‍♀️     
그래서 이 부분은 <strong>실제 아이폰에 빌드를 넣어서 확인</strong>해야 한다.      
 
</div>


@IBOutlet 연결 시에 입력하는 항목 중 [Storage]는 Strong/Weak 두 가지 값 중에서 선택할 수 있다.    
**기본값은 Strong 타입**. 

**Strong과 Weak 타입의 차이는 <u>메모리 회수 정책</u>에 있다.** 일반적으로 변수나 상수는 다른 곳에서 참조되고 있을 경우 메모리에서 제거되지 않는 것이 원칙이지만, Weak 타입으로 선언된 변수나 상수는 다른 곳에서 참조되고 있더라도 시스템이 임의로 메모리에서 제거할 수 있다.

저장된 값이 지워질 수 있는 불안함에도 불구하고 Weak 타입이 필요한 이유는 메모리 관리 때문이다! 
Strong 타입 객체들끼리 상호 참조되는 일이 발생하는 경우, 어떤 경우에도 참조 카운트가 0이 되지 않으므로 애플리케이션이 실행되는 한 영원히 메모리에서 제거되지 않는다. 이는 곧 메모리 누수로 이어짐.
이를 바로 Weak 타입을 통해 해결할 수 있다는 것!

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>     

더 자세한 내용은 아래 링크 참고!     

<strong><a href   =   "https://ahyeonlog.tistory.com/3">  강한 참조와 약한 참조! 순환 참조 사이클 해결방법, 약한 참조(weak)와 비소유(unowned)참조   </a> </strong>     
 
</div>


## 🖋 @IBAction - 객체의 이벤트 제어

**객체의 이벤트를 제어할 때 사용하는 어노테이션**으로, 특정 객체에서 지정된 이벤트가 발생했을 때 우리가 의도하는 일련의 프로세스를 실행케 할 목적을 가진다. 이를 위해 이 어노테이션은 메소드와 함께 사용되는데, 우리는 이를 **액션 메소드**라고 부름.    

액션 메소드는 버튼이나 테이블 셀 등 **사용자와 상호 반응할 수 있는 객체**를 연결할 때만 사용할 수 있다는 제한이 있다. 

또한 다양한 이벤트 중에서 **어떤 것을 감지하여 실행할 것이냐에 대한 항목**도 따로 설정해야 한다. (ex. 버튼 터치, 드래그, 쓸어넘기기 등)


## 🖋 인터페이스 빌더 객체와 클래스를 연결하는 방법


<div class="notice--primary" markdown="1">
💡 <strong><u>추가 지식</u> !</strong>     

- <strong>ViewController</strong> : 스토리 보드의 기본 뷰 컨트롤러로 UIViewController 클래스를 상속받은 클래스    

- <strong>AppDelegate 클래스</strong> : 앱 전체가 실행되고 종료될 때의 전체 컨트롤을 위임받은 앱 델리게이트 객체       
 
</div>


### 📌 스토리보드의 객체를 클래스와 연결

### 📌 커넥션 인스펙터 탭 사용

### 📌 보조 에디터 사용

**<u>아울렛 변수의 초기값</u>**은 앱이 실행될 때 코코아 터치 프레임워크에 의해 주입되기 때문에 **<u>우리가 임의로 지정할 수 없다</u>!**

**아울렛 변수에 타입 어노테이션을 작성**할 때 **옵서녈 연산자**인 **<u>!</u>**를 추가하는데, 이는 **<u>묵시적 옵셔녈 해제</u>**를 뜻한다.

일반적으로 클래스에서 초기화되지 않은 프로퍼티는 모두 옵셔녈이어야 하지만, 옵서녈로 선언하면 이후로 옵셔녈 체인을 이용하여 구문을 작성해야 할 뿐만 아니라 옵셔녈 체크가 필요한 부분도 많으므로 불편하다.
그 대신 **옵셔녈 해제 연산자를 붙여 정의해 두면 <u>선언할 때에는 옵서녈 타입이지만 일반 타입처럼 사용</u>할 수 있다**는 장점이 생김!

### 📌 커넥션 인스펙터 탭 사용

### 📌 문서 개요창 활용 


## 추가적인 TIP

### 🤔 그런테 ViewController 클래스에서 viewDidLoad() 메소드를 사용하지 않는데도 꼭 있어야 할까?   


딱히 하는 역할이 없다면 굳이 작성하지 않아도 된다!
상위 클래스에서 이미 선언되어 있고, ViewController 클래스에서는 이를 오버라이드하고 있지만, 특별하게 추가하는 내용은 현재 없다는 뜻이므로!
그냥 놔두어도 부모 메소드에서 알아서 실행될 테니까.

다만 viewDidLoad()는 실제로는 꽤 많은 일을 하는 상황이 많기에 **평소에는 지우지 않는 걸 추천!** 
**지워도 될 때는 오직 하나, <u>아무일도 하지 않을 때 뿐</u>.**

### 🤔 소스 코드 정리?

클래스 내에서 **프로퍼티는 프로퍼티끼리, 메소드는 메소드끼리 모아놓는 편이 유지보수나 관리에 용이**하다!

